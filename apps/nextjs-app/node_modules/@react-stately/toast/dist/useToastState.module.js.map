{"mappings":"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","sources":["packages/@react-stately/toast/src/useToastState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useMemo} from 'react';\n// Shim to support React 17 and below.\nimport {useSyncExternalStore} from 'use-sync-external-store/shim/index.js';\n\nexport interface ToastStateProps {\n  /** The maximum number of toasts to display at a time. */\n  maxVisibleToasts?: number,\n  /**\n   * Whether toasts have an exit animation. If true, toasts are not\n   * removed immediately but transition into an \"exiting\" state instead.\n   * Once the animation is complete, call the `remove` function.\n   */\n  hasExitAnimation?: boolean\n}\n\nexport interface ToastOptions {\n  /** Handler that is called when the toast is closed, either by the user or after a timeout. */\n  onClose?: () => void,\n  /** A timeout to automatically close the toast after, in milliseconds. */\n  timeout?: number,\n  /** The priority of the toast relative to other toasts. Larger numbers indicate higher priority. */\n  priority?: number\n}\n\nexport interface QueuedToast<T> extends ToastOptions {\n  /** The content of the toast. */\n  content: T,\n  /** A unique key for the toast. */\n  key: string,\n  /** A timer for the toast, if a timeout was set. */\n  timer?: Timer,\n  /** The current animation state for the toast. */\n  animation?: 'entering' | 'queued' | 'exiting' | null\n}\n\nexport interface ToastState<T> {\n  /** Adds a new toast to the queue. */\n  add(content: T, options?: ToastOptions): string,\n  /**\n   * Closes a toast. If `hasExitAnimation` is true, the toast\n   * transitions to an \"exiting\" state instead of being removed immediately.\n   */\n  close(key: string): void,\n  /** Removes a toast from the visible toasts after an exiting animation. */\n  remove(key: string): void,\n  /** Pauses the timers for all visible toasts. */\n  pauseAll(): void,\n  /** Resumes the timers for all visible toasts. */\n  resumeAll(): void,\n  /** The visible toasts. */\n  visibleToasts: QueuedToast<T>[]\n}\n\n/**\n * Provides state management for a toast queue. Toasts display brief, temporary notifications\n * of actions, errors, or other events in an application.\n */\nexport function useToastState<T>(props: ToastStateProps = {}): ToastState<T> {\n  let {maxVisibleToasts = 1, hasExitAnimation = false} = props;\n  let queue = useMemo(() => new ToastQueue<T>({maxVisibleToasts, hasExitAnimation}), [maxVisibleToasts, hasExitAnimation]);\n  return useToastQueue(queue);\n}\n\n/**\n * Subscribes to a provided toast queue and provides methods to update it.\n */\nexport function useToastQueue<T>(queue: ToastQueue<T>): ToastState<T> {\n  let subscribe = useCallback(fn => queue.subscribe(fn), [queue]);\n  let getSnapshot = useCallback(() => queue.visibleToasts, [queue]);\n  let visibleToasts = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n\n  return {\n    visibleToasts,\n    add: (content, options) => queue.add(content, options),\n    close: key => queue.close(key),\n    remove: key => queue.remove(key),\n    pauseAll: () => queue.pauseAll(),\n    resumeAll: () => queue.resumeAll()\n  };\n}\n\n/**\n * A ToastQueue is a priority queue of toasts.\n */\nexport class ToastQueue<T> {\n  private queue: QueuedToast<T>[] = [];\n  private subscriptions: Set<() => void> = new Set();\n  private maxVisibleToasts: number;\n  private hasExitAnimation: boolean;\n  /** The currently visible toasts. */\n  visibleToasts: QueuedToast<T>[] = [];\n\n  constructor(options?: ToastStateProps) {\n    this.maxVisibleToasts = options?.maxVisibleToasts ?? 1;\n    this.hasExitAnimation = options?.hasExitAnimation ?? false;\n  }\n\n  /** Subscribes to updates to the visible toasts. */\n  subscribe(fn: () => void) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n\n  /** Adds a new toast to the queue. */\n  add(content: T, options: ToastOptions = {}) {\n    let toastKey = Math.random().toString(36);\n    let toast: QueuedToast<T> = {\n      ...options,\n      content,\n      key: toastKey,\n      timer: options.timeout ? new Timer(() => this.close(toastKey), options.timeout) : undefined\n    };\n\n    let low = 0;\n    let high = this.queue.length;\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n      if ((toast.priority || 0) > (this.queue[mid].priority || 0)) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    this.queue.splice(low, 0, toast);\n\n    toast.animation = low < this.maxVisibleToasts ? 'entering' : 'queued';\n    let i = this.maxVisibleToasts;\n    while (i < this.queue.length) {\n      this.queue[i++].animation = 'queued';\n    }\n\n    this.updateVisibleToasts({action: 'add'});\n    return toastKey;\n  }\n\n  /**\n   * Closes a toast. If `hasExitAnimation` is true, the toast\n   * transitions to an \"exiting\" state instead of being removed immediately.\n   */\n  close(key: string) {\n    let index = this.queue.findIndex(t => t.key === key);\n    if (index >= 0) {\n      this.queue[index].onClose?.();\n      this.queue.splice(index, 1);\n    }\n\n    this.updateVisibleToasts({action: 'close', key});\n  }\n\n  /** Removes a toast from the visible toasts after an exiting animation. */\n  remove(key: string) {\n    this.updateVisibleToasts({action: 'remove', key});\n  }\n\n  private updateVisibleToasts(options: {action: 'add' | 'close' | 'remove', key?: string}) {\n    let {action, key} = options;\n    let toasts = this.queue.slice(0, this.maxVisibleToasts);\n\n    if (action === 'add' && this.hasExitAnimation) {\n      let prevToasts: QueuedToast<T>[] = this.visibleToasts\n        .filter(t => !toasts.some(t2 => t.key === t2.key))\n        .map(t => ({...t, animation: 'exiting'}));\n      this.visibleToasts = prevToasts.concat(toasts).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n    } else if (action === 'close' && this.hasExitAnimation) {\n      // Cause a rerender to happen for exit animation\n      this.visibleToasts = this.visibleToasts.map(t => {\n        if (t.key !== key) {\n          return t;\n        } else {\n          return {...t, animation: 'exiting'};\n        }\n      });\n    } else {\n      this.visibleToasts = toasts;\n    }\n\n    for (let fn of this.subscriptions) {\n      fn();\n    }\n  }\n\n  /** Pauses the timers for all visible toasts. */\n  pauseAll() {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.pause();\n      }\n    }\n  }\n\n  /** Resumes the timers for all visible toasts. */\n  resumeAll() {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.resume();\n      }\n    }\n  }\n}\n\nclass Timer {\n  private timerId;\n  private startTime: number | null = null;\n  private remaining: number;\n  private callback: () => void;\n\n  constructor(callback: () => void, delay: number) {\n    this.remaining = delay;\n    this.callback = callback;\n  }\n\n  reset(delay: number) {\n    this.remaining = delay;\n    this.resume();\n  }\n\n  pause() {\n    if (this.timerId == null) {\n      return;\n    }\n\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.remaining -= Date.now() - this.startTime!;\n  }\n\n  resume() {\n    if (this.remaining <= 0) {\n      return;\n    }\n\n    this.startTime = Date.now();\n    this.timerId = setTimeout(() => {\n      this.timerId = null;\n      this.remaining = 0;\n      this.callback();\n    }, this.remaining);\n  }\n}\n"],"names":[],"version":3,"file":"useToastState.module.js.map"}